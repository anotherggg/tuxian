{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// 1.创建一个新的axios实例\n// 2.请求拦截器，如果有token进行头部携带\n// 3.响应拦截器：1.剥离无效数据  2.处理token失效\n// 4.导出一个函数，调用当前的axsio实例发请求，返回值promise\n\nimport axios from 'axios';\nimport store from '@/store';\nimport router from '@/router';\n\n// 导出基准地址，原因：其他地方不是通过axios发请求的地方用上基准地址\nexport const baseURL = 'http://pcapi-xiaotuxian-front-devtest.itheima.net/';\nconst instance = axios.create({\n  // axios的一些配置，baseURL timeout\n  baseURL,\n  timeout: 5000\n});\ninstance.interceptors.request.use(config => {\n  // 拦截业务逻辑\n  // 进行请求配置的修改\n  // 如果本地有token就在头部携带\n  // 1.获取用户信息对象\n  const {\n    profile\n  } = store.state.user;\n  // 2.判断是否有token\n  if (profile.token) {\n    // 3.设置token\n    config.headers.Authorization = `Bearer${profile.token}`;\n  }\n  return config;\n}, err => {\n  return Promise.reject(err);\n});\n\n// res=>res.data 取出data数据,将来调用接口的时候直接拿到的就是后台的数据\ninstance.interceptors.response.use(res => res.data, err => {\n  // 401状态码，进入该函数\n  if (err.response && err.response.status === 401) {\n    // 1.清空无效用户信息\n    // 2. 跳转到登陆页\n    // 3. 跳转需要传参（当前路由地址）给登录页码\n    store.commit('user/setUser', {});\n    // 当前路由地址\n    // 组件里头：`/user?a=10` $route.path === /user  $route.fullPath === /user?a=10\n    // js模块中： router.currentRoute.value.fullPath就是当前路由地址，router.currentRoute 是re响应式数据\n    const fullPath = encodeURIComponent(router.currentRoute.value.fullPath);\n    // encodeURIComponent转换uri编码，防止解析地址出问题\n    router.push('/login?redirectUrl=' + fullPath);\n  }\n  return Promise.reject(err);\n});\n\n// 请求工具函数\nexport default ((url, method, submitData) => {\n  // 负责发请求：请求地址，请求方式，提交的数据\n  return instance({\n    url,\n    method,\n    // 1. 如果是get请求  需要使用params来传递submitData   ?a=10&c=10\n    // 2. 如果不是get请求  需要使用data来传递submitData   请求体传参\n    // []设置一个动态的key，写js表达式，js表达式的执行结果当作KEY\n    // method参数：get,Get,GET 转换成小写再来判断\n    // 在对象，['params']:submitData ===== params:submitData 这样理解\n    [method.toLowerCase() === 'get' ? 'params' : 'data']: submitData\n  });\n});","map":{"version":3,"names":["axios","store","router","baseURL","instance","create","timeout","interceptors","request","use","config","profile","state","user","token","headers","Authorization","err","Promise","reject","response","res","data","status","commit","fullPath","encodeURIComponent","currentRoute","value","push","url","method","submitData","toLowerCase"],"sources":["E:/自己写的项目/tuxian/erabbit-pc-vue-project/src/utils/request.js"],"sourcesContent":["// 1.创建一个新的axios实例\n// 2.请求拦截器，如果有token进行头部携带\n// 3.响应拦截器：1.剥离无效数据  2.处理token失效\n// 4.导出一个函数，调用当前的axsio实例发请求，返回值promise\n\nimport axios from 'axios';\nimport store from '@/store';\nimport router from '@/router';\n\n// 导出基准地址，原因：其他地方不是通过axios发请求的地方用上基准地址\nexport const baseURL = 'http://pcapi-xiaotuxian-front-devtest.itheima.net/';\nconst instance = axios.create({\n  // axios的一些配置，baseURL timeout\n  baseURL,\n  timeout: 5000,\n});\n\ninstance.interceptors.request.use(\n  (config) => {\n    // 拦截业务逻辑\n    // 进行请求配置的修改\n    // 如果本地有token就在头部携带\n    // 1.获取用户信息对象\n    const { profile } = store.state.user;\n    // 2.判断是否有token\n    if (profile.token) {\n      // 3.设置token\n      config.headers.Authorization = `Bearer${profile.token}`;\n    }\n    return config;\n  },\n  (err) => {\n    return Promise.reject(err);\n  }\n);\n\n// res=>res.data 取出data数据,将来调用接口的时候直接拿到的就是后台的数据\ninstance.interceptors.response.use(\n  (res) => res.data,\n  (err) => {\n    // 401状态码，进入该函数\n    if (err.response && err.response.status === 401) {\n      // 1.清空无效用户信息\n      // 2. 跳转到登陆页\n      // 3. 跳转需要传参（当前路由地址）给登录页码\n      store.commit('user/setUser', {});\n      // 当前路由地址\n      // 组件里头：`/user?a=10` $route.path === /user  $route.fullPath === /user?a=10\n      // js模块中： router.currentRoute.value.fullPath就是当前路由地址，router.currentRoute 是re响应式数据\n      const fullPath = encodeURIComponent(router.currentRoute.value.fullPath);\n      // encodeURIComponent转换uri编码，防止解析地址出问题\n      router.push('/login?redirectUrl=' + fullPath);\n    }\n    return Promise.reject(err);\n  }\n);\n\n// 请求工具函数\nexport default (url, method, submitData) => {\n  // 负责发请求：请求地址，请求方式，提交的数据\n  return instance({\n    url,\n    method,\n    // 1. 如果是get请求  需要使用params来传递submitData   ?a=10&c=10\n    // 2. 如果不是get请求  需要使用data来传递submitData   请求体传参\n    // []设置一个动态的key，写js表达式，js表达式的执行结果当作KEY\n    // method参数：get,Get,GET 转换成小写再来判断\n    // 在对象，['params']:submitData ===== params:submitData 这样理解\n    [method.toLowerCase() === 'get' ? 'params' : 'data']: submitData,\n  });\n};\n"],"mappings":";AAAA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,KAAK,MAAM,SAAS;AAC3B,OAAOC,MAAM,MAAM,UAAU;;AAE7B;AACA,OAAO,MAAMC,OAAO,GAAG,oDAAoD;AAC3E,MAAMC,QAAQ,GAAGJ,KAAK,CAACK,MAAM,CAAC;EAC5B;EACAF,OAAO;EACPG,OAAO,EAAE;AACX,CAAC,CAAC;AAEFF,QAAQ,CAACG,YAAY,CAACC,OAAO,CAACC,GAAG,CAC9BC,MAAM,IAAK;EACV;EACA;EACA;EACA;EACA,MAAM;IAAEC;EAAQ,CAAC,GAAGV,KAAK,CAACW,KAAK,CAACC,IAAI;EACpC;EACA,IAAIF,OAAO,CAACG,KAAK,EAAE;IACjB;IACAJ,MAAM,CAACK,OAAO,CAACC,aAAa,GAAI,SAAQL,OAAO,CAACG,KAAM,EAAC;EACzD;EACA,OAAOJ,MAAM;AACf,CAAC,EACAO,GAAG,IAAK;EACP,OAAOC,OAAO,CAACC,MAAM,CAACF,GAAG,CAAC;AAC5B,CAAC,CACF;;AAED;AACAb,QAAQ,CAACG,YAAY,CAACa,QAAQ,CAACX,GAAG,CAC/BY,GAAG,IAAKA,GAAG,CAACC,IAAI,EAChBL,GAAG,IAAK;EACP;EACA,IAAIA,GAAG,CAACG,QAAQ,IAAIH,GAAG,CAACG,QAAQ,CAACG,MAAM,KAAK,GAAG,EAAE;IAC/C;IACA;IACA;IACAtB,KAAK,CAACuB,MAAM,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;IAChC;IACA;IACA;IACA,MAAMC,QAAQ,GAAGC,kBAAkB,CAACxB,MAAM,CAACyB,YAAY,CAACC,KAAK,CAACH,QAAQ,CAAC;IACvE;IACAvB,MAAM,CAAC2B,IAAI,CAAC,qBAAqB,GAAGJ,QAAQ,CAAC;EAC/C;EACA,OAAOP,OAAO,CAACC,MAAM,CAACF,GAAG,CAAC;AAC5B,CAAC,CACF;;AAED;AACA,gBAAe,CAACa,GAAG,EAAEC,MAAM,EAAEC,UAAU,KAAK;EAC1C;EACA,OAAO5B,QAAQ,CAAC;IACd0B,GAAG;IACHC,MAAM;IACN;IACA;IACA;IACA;IACA;IACA,CAACA,MAAM,CAACE,WAAW,EAAE,KAAK,KAAK,GAAG,QAAQ,GAAG,MAAM,GAAGD;EACxD,CAAC,CAAC;AACJ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}